// This file is automatically generated. Do not edit it directly.
import { createClient, type User } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://rifdykpdubrowzbylffe.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJpZmR5a3BkdWJyb3d6YnlsZmZlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3OTc5NDMsImV4cCI6MjA2OTM3Mzk0M30.lhSbTbVWckd9zsT0hRCAO06nPKszZpKNi_sq6-WPmV8";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Lightweight cache wrapper to reduce repetitive auth.getUser network calls
// Many components call getUser during mount; cache successful responses briefly and
// update cache on auth state changes. Avoid caching null users to prevent stale state.
try {
  // @ts-expect-error augment runtime method
  const originalGetUser = supabase.auth.getUser.bind(supabase.auth);
  type GetUserResult = Awaited<ReturnType<typeof originalGetUser>>;
  let cachedUser: User | null = null;
  let cachedAt = 0;
  let inflight: Promise<GetUserResult> | null = null;
  // Increase cache TTL to reduce auth.getUser network calls,
  // which were contributing to ~12 auth requests/min.
  const TTL = 60_000; // 60 seconds

  // Keep cache in sync with auth events
  const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
    cachedUser = session?.user ?? null;
    cachedAt = Date.now();
  });
  // Best-effort cleanup on hot reload
  if (import.meta && import.meta.hot) {
    import.meta.hot.on('supabase-auth-cache-dispose', () => subscription.unsubscribe());
  }

  // @ts-expect-error override runtime method
  supabase.auth.getUser = async () => {
    const now = Date.now();
    if (cachedUser && now - cachedAt < TTL) {
      return { data: { user: cachedUser }, error: null } as GetUserResult;
    }
    if (inflight) {
      return inflight;
    }
    inflight = originalGetUser().then((res: GetUserResult) => {
      const user = res?.data?.user ?? null;
      // Only cache if we actually have a user; avoid caching null
      if (user) {
        cachedUser = user;
        cachedAt = Date.now();
      }
      inflight = null;
      return res;
    }).catch((err: unknown) => {
      inflight = null;
      return { data: { user: null }, error: err } as GetUserResult;
    });
    return inflight;
  };
} catch {
  // no-op: if override fails, fall back to default behavior
}
